

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta content="Topic: recording sound, Category: Section" name="description" />
<meta content="analog, digital, pcm, pulse code modulation, sample rate, bit depth, nyquist" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Digitizing an Analog Signal &mdash; CogWorks</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/my_theme.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Exercises: Working with the Microphone" href="Exercises/WorkingWithMic.html" />
    <link rel="prev" title="Microphones: Recording Sound as an Analog Signal" href="recording_sound.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> CogWorks
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">CogWorks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pre_reqs.html">Course Pre-Requisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../supplemental_math.html">Supplemental Math Materials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../audio.html">Audio Module</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="prereqs.html">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="physics-of-sound.html">The Basics of Sound</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exercises/AudioSignalBasics.html">Exercises: Basics of Sound Waves</a></li>
<li class="toctree-l2"><a class="reference internal" href="recording_sound.html">Microphones: Recording Sound as an Analog Signal</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Digitizing an Analog Signal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Sampling-Rate">Sampling Rate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Bit-Depth">Bit Depth</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Computer-Memory:-bits-and-bytes">Computer Memory: bits and bytes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Quantizing-and-Digitizing-Measurements">Quantizing and Digitizing Measurements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Reading-Comprehension-Exercise-Solutions">Reading Comprehension Exercise Solutions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Code-For-Reproducing-Figures">Code For Reproducing Figures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Discretizing-an-Analog-Signal-in-Time">Discretizing an Analog Signal in Time</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Quantizing-Sine">Quantizing Sine</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="Exercises/WorkingWithMic.html">Exercises: Working with the Microphone</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exercises/AnalogToDigital.html">Exercises: Analog to Digital Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="fourier_analysis.html">Decomposing Audio Signals: Fourier Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="discrete_fourier_transforms.html">The Discrete Fourier Transform (DFT)</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exercises/BasicsOfDFT.html">Exercises: Basics of DFTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exercises/DFTOfVariousSignals.html">Exercises: DFTs of Various Signals</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exercises/ApplicationsOfDFTs.html">Exercises: Applications of DFTs</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro_spectrograms.html">Introduction to Spectrogram Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exercises/spectrogram.html">Exercise: Creating Our Own Spectrogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="audio_features.html">Matching Audio Recordings</a></li>
<li class="toctree-l2"><a class="reference internal" href="Exercises/PeakFinding.html">Exercises: Finding Local Peaks in a 2-D Array</a></li>
<li class="toctree-l2"><a class="reference internal" href="capstone_summary.html">Capstone Project: Song Recognition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../vision.html">Vision Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language.html">Language Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cheat_sheet.html">Cheat Sheets</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CogWorks</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../audio.html">Audio Module</a> &raquo;</li>
        
      <li>Digitizing an Analog Signal</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Audio/digitizing_signals.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container,
div.nbinput.container div.prompt,
div.nbinput.container div.input_area,
div.nbinput.container div[class*=highlight],
div.nbinput.container div[class*=highlight] pre,
div.nboutput.container,
div.nboutput.container div.prompt,
div.nboutput.container div.output_area,
div.nboutput.container div[class*=highlight],
div.nboutput.container div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    min-width: 5ex;
    padding-top: 0.3rem;
    padding-right: 0.3rem;
    text-align: right;
    flex: 0;
}
@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    background: #f5f5f5;
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 0.3rem;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="Digitizing-an-Analog-Signal">
<h1>Digitizing an Analog Signal<a class="headerlink" href="#Digitizing-an-Analog-Signal" title="Permalink to this headline">¶</a></h1>
<p>A voltmeter provides us with a continuous read out of the electrical signal that is produced by our microphone. As defined earlier, this means that we are working with an analog signal. We want to record this signal to some sort of digital file so that our audio recording can be replayed and analyzed later. As far as we’re are concerned, the proverbial needle on our voltmeter can land anywhere on a continuum of volt values and its exact position on that continuum varies smoothly in time.
Describing the <em>exact</em> evolution of measurements being made by the voltmeter would amount to us discovering a symbolic representation (i.e. a mathematical function) that perfectly describes its behavior over time. This is not viable; not at all.</p>
<p>Instead, we will proceed to <strong>discretize the measurements of our voltmeter in both time and magnitude</strong>. That is, we will pick distinct moments in time at which we will record values of our voltmeter. At these select times, we will record numbers (whose units are volts) up to some some limited numerical precision. This means that, to an extent, we will not care about minor differences in the exact pointing direction of the voltmeter’s needle. In practice, this means that will write down our
numbers up to a limited number of decimal places. We will then represent these measurements as numbers that a computer can understand. The process just described amounts to <strong>encoding our analog signal as a digital signal</strong>.</p>
<div style="text-align: center">
<p>
<img src="../_images/analog_to_digital_overview.png" alt="Evenly-spaced temporal samples" width="900">
</p>
</div><p>While there are many ways to go about digitizing an analog signal, we will be focusing on a particularly simple method known as <strong>pulse code modulation (PCM)</strong>. The method of PCM simply requires that we specify two quantities in order to define our sampling process:</p>
<ol class="arabic simple">
<li><p><strong>Sampling rate</strong>, <span class="math notranslate nohighlight">\(f_s\)</span>, which determines how frequently we record measurements from the voltmeter.</p></li>
<li><p><strong>Bit depth</strong>, <span class="math notranslate nohighlight">\(N_b\)</span>, which effectively determines the precision with which we record our measurements. To be explicit, it specifies <em>how much computer memory</em> we are willing use to store each measurement.</p></li>
</ol>
<div class="section" id="Sampling-Rate">
<h2>Sampling Rate<a class="headerlink" href="#Sampling-Rate" title="Permalink to this headline">¶</a></h2>
<p>The sampling rate of the PCM process is denoted by <span class="math notranslate nohighlight">\(f_s\)</span>; it simply specifies the number of <strong>evenly-spaced</strong> samples, or measurements, that we should record from our voltmeter in a given unit of time, starting at the earliest possible time. We can use units of Hertz (<span class="math notranslate nohighlight">\(\mathrm{Hz}\)</span>) to specify the number of samples to collect per second. Thus if our recording has a duration of <span class="math notranslate nohighlight">\(T\)</span>, then we will record</p>
<div class="math notranslate nohighlight">
\begin{equation}
N_{\mathrm{samples}} = \lfloor f_s T \rfloor + 1
\end{equation}</div><p>number of samples. We must always record an integer number of samples, which is why we take the “floor” of <span class="math notranslate nohighlight">\(f_s T\)</span>. The floor operator is denoted by <span class="math notranslate nohighlight">\(\lfloor \;\rfloor\)</span>, and behaves by returning the smallest integer neighbor to the number that it operates on; e.g. <span class="math notranslate nohighlight">\(\lfloor 3.92 \rfloor = 3\)</span>. Thus, given an arbitrary analog signal represented by <span class="math notranslate nohighlight">\(f(t)\)</span> that lasts for a duration <span class="math notranslate nohighlight">\(T\)</span>, we will record <span class="math notranslate nohighlight">\(N_{\mathrm{samples}}\)</span> at intervals of
<span class="math notranslate nohighlight">\(\Delta t = \frac{1}{f_s}\)</span>:</p>
<div class="math notranslate nohighlight">
\begin{equation}
f(t) \rightarrow \big[f(0),\;f(\Delta t),\;f(2 \Delta t),\ldots ,\;f((N_{\mathrm{samples}} - 1)\Delta t)\big]
\end{equation}</div><p>The following plot depicts an analog signal (indicated by the smoothly-varying dashed blue line) that is sampled at a rate of <span class="math notranslate nohighlight">\(1 \; \mathrm{Hz}\)</span>. The code for reproducing this plot is included at the bottom of this page. It is advised that you experiment with the sampling rate and see how it affects the appearance of this plot.</p>
<div style="text-align: center">
<p>
<img src="../_images/temporal_samples.png" alt="Evenly-spaced temporal samples" width="600">
</p>
</div><div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>Reading Comprehension: Sample Rate</strong></p>
<p>Given an analog signal that lasts for <span class="math notranslate nohighlight">\(127.2 \; \mathrm{seconds}\)</span>, if we use sample at a rate of <span class="math notranslate nohighlight">\(0.5 \; \mathrm{Hz}\)</span>, how many samples should we expect to collect? Compute your answer using pen and paper and using Python. Note that you can import the <code class="docutils literal notranslate"><span class="pre">floor</span></code> function from the standard library’s <code class="docutils literal notranslate"><span class="pre">math</span></code> module, or you can simply call <code class="docutils literal notranslate"><span class="pre">int()</span></code> on the number to the same effect.</p>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>Reading Comprehension: Writing a Sampler</strong></p>
<p>Complete the body of the following Python function that will extract samples that are evenly-spaced in time from an analog signal:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">temporal_sampler</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts samples from an analog signal according to the specified sampling rate,</span>
<span class="sd">    returning the times and the corresponding samples</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : Callable[[ndarray], ndarray]</span>
<span class="sd">        Another Python function (i.e. a &quot;callable&quot;), which behaves like f(t)</span>
<span class="sd">        and accepts a time value (in seconds) as an input and returns a</span>
<span class="sd">        measurement (in volts) as an output. You can expect this to behave like</span>
<span class="sd">        a vectorized function i.e. it can be passed a NumPy-array of input times</span>
<span class="sd">        and it will return a corresponding array of measurements.</span>

<span class="sd">    duration : float</span>
<span class="sd">        The duration of the signal, specified in seconds (a non-negative float)</span>

<span class="sd">    sampling_rate : float</span>
<span class="sd">        The sampling rate specified in Hertz.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (times, samples) : Tuple[ndarray, ndarray]</span>
<span class="sd">        The shape-(N,) array of times and the corresponding shape-(N,) array</span>
<span class="sd">        samples extracted from the analog signal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
<p><strong>The standard PCM sampling rate used by the audio industry is</strong> <span class="math notranslate nohighlight">\(44,100\;\mathrm{Hz}\)</span>. This number is based on the range of audio frequencies that humans can perceive – we can hear up to roughly <span class="math notranslate nohighlight">\(20,000\;\mathrm{Hz}\)</span>. To gain some insight into this, complete the following exercise.</p>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>Reading Comprehension: Aliasing</strong></p>
<p><strong>Aliasing</strong> is said to occur when the sampling process causes distinct signals to appear as being indistinguishable from one another. This exercise will demonstrate simple instance of temporal aliasing.</p>
<p>Using the analog signal</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># Hz</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot this <span class="math notranslate nohighlight">\(10 \; \mathrm{Hz}\)</span> sinusoidal signal densely (using many points, so that it appears to be continuous) over a <span class="math notranslate nohighlight">\(0.5 \;\mathrm{second}\)</span> interval. Now, use your <code class="docutils literal notranslate"><span class="pre">temporal_sampler</span></code> function from the previous exercise to sample this signal, <strong>using a sampling rate that matches the frequency of the signal</strong> (<span class="math notranslate nohighlight">\(10 \; \mathrm{Hz}\)</span>); plot these samples on top of the analog signal. What do you notice about these samples? What is the simplest analog signal that you can imagine
that would produce the exact same samples? Put another way: if all you saw were these samples, what is the analog signal that would you <em>think</em> they describe?</p>
<p>Now, re-sample the signal at with the sampling rate doubled and plot the results. Do these samples do a better job of representing our signal?</p>
<p>This doubling between the highest frequency of an analog signal and the minimum viable sampling rate needed to discretize it “faithfully” has a special name: this sampling rate is known as the “Nyquist rate”, as prescribed by the <a class="reference external" href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">Nyquist–Shannon sampling theorem</a>. In general, one needs to use a sampling rate that exceeds the Nyquist rate (twice the highest-frequency component of the analog signal) in order to be able to
faithfully reconstruct the analog signal from the samples.</p>
<p>Reflecting on this, and given that we humans can perceive tones with frequencies up to roughly <span class="math notranslate nohighlight">\(20,000\;\mathrm{Hz}\)</span>, why might the audio industry use a sampling rate of <span class="math notranslate nohighlight">\(44,100\;\mathrm{Hz}\)</span> for digitizing audio signals?</p>
<p>(Aside: If you have ever tweaked an “anti-aliasing” parameter in a video game’s settings, this is to help prevent aliasing in the spatially-sampled illumination values that will be displayed on your screen, which can cause undesirable pixelation effects.)</p>
</div>
</div>
<div class="section" id="Bit-Depth">
<h2>Bit Depth<a class="headerlink" href="#Bit-Depth" title="Permalink to this headline">¶</a></h2>
<p>We just reviewed the process of discretizing our analog signal in time by establishing a temporal sampling rate. Now we will discretize the <em>magnitudes</em> of the values that we record from out voltmeter; we will do this by establishing a <strong>bit-depth</strong> for our digitization process. This will, in effect, decide the number of “significant digits” that we use to record our measurements.</p>
<div class="section" id="Computer-Memory:-bits-and-bytes">
<h3>Computer Memory: bits and bytes<a class="headerlink" href="#Computer-Memory:-bits-and-bytes" title="Permalink to this headline">¶</a></h3>
<p>The bit-depth of our measurements is the amount of computer memory – measured in <strong>bits</strong> – that we will dedicate to storing each one of our measurements. A single bit is capable of storing two states, which we can think of a <span class="math notranslate nohighlight">\(0\)</span> or a <span class="math notranslate nohighlight">\(1\)</span>; that is, it is a unit of memory that can store one “<strong>b</strong>inary dig<strong>it</strong>”. Thus a sequence of two bits together can represent distinct <span class="math notranslate nohighlight">\(4\)</span> states:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">)</span> <span class="mi">00</span>
<span class="mi">2</span><span class="p">)</span> <span class="mi">01</span>
<span class="mi">3</span><span class="p">)</span> <span class="mi">10</span>
<span class="mi">4</span><span class="p">)</span> <span class="mi">11</span>
</pre></div>
</div>
<p>A sequence of three bits can represent <span class="math notranslate nohighlight">\(8\)</span> distinct states:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">)</span> <span class="mi">000</span>
<span class="mi">2</span><span class="p">)</span> <span class="mi">001</span>
<span class="mi">3</span><span class="p">)</span> <span class="mi">010</span>
<span class="mi">4</span><span class="p">)</span> <span class="mi">011</span>
<span class="mi">5</span><span class="p">)</span> <span class="mi">100</span>
<span class="mi">6</span><span class="p">)</span> <span class="mi">101</span>
<span class="mi">7</span><span class="p">)</span> <span class="mi">110</span>
<span class="mi">8</span><span class="p">)</span> <span class="mi">111</span>
</pre></div>
</div>
<p>We can deduce that, in general, a sequence of <span class="math notranslate nohighlight">\(N_b\)</span> bits can represent <span class="math notranslate nohighlight">\(2 ^ {N_{b}}\)</span> distinct states. An important note of terminology: 8 bits corresponds to a <strong>byte</strong>, in the jargon of computer science. Thus a megabyte is <span class="math notranslate nohighlight">\(10^6\)</span> bytes, or <span class="math notranslate nohighlight">\(8 \times 10^6\)</span> bits, of memory, and a gigabyte is <span class="math notranslate nohighlight">\(10^9\)</span> bytes.</p>
</div>
<div class="section" id="Quantizing-and-Digitizing-Measurements">
<h3>Quantizing and Digitizing Measurements<a class="headerlink" href="#Quantizing-and-Digitizing-Measurements" title="Permalink to this headline">¶</a></h3>
<p>Once we decide on a bit-depth — the number of bits that we will afford to each of our measurements — then we know the number of distinct values that we are capable of recording. Thus we must <em>quantize</em> the measurements from our voltmeter, which produces readouts on a continuum of values, accordingly. That is, if we were to choose a bit-depth of 8, then we need would need to “bin” the measurements of our voltmeter so that any readout that it provides can be associated with one of
<span class="math notranslate nohighlight">\(2 ^ {8} = 256\)</span> distinct values (in units of volts). This is no different than taking a <span class="math notranslate nohighlight">\(1 \;\mathrm{meter}\)</span> ruler and deciding that we are going to take measurements to the nearest centimeter: while the ruler can be used to measure lengths on a continuum, our measurements will only be able to take on one of <span class="math notranslate nohighlight">\(100\)</span> values, according to the nearest centimeter “tick” that our measurement falls against.</p>
<p>The following figure shows one period of a sine wave quantized using various bit-depths.</p>
<div style="text-align: center">
<p>
<img src="../_images/quantized_sine.png" alt="Sine quantized using various bit-depths" width="700">
</p>
</div><p>Note that the number of quantized steps available, <span class="math notranslate nohighlight">\(2 ^ {N_{b}}\)</span>, increases exponentially with the number of bits that we allot per measurement; thus the apparent smoothness of the quantized signal improves rapidly with increasing bit-depth.</p>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>Reading Comprehension: Quantization</strong></p>
<p>Write a python function called <code class="docutils literal notranslate"><span class="pre">quantize</span></code>, which performs the quantization process discussed above. Read the docstring for the function “stub” provided below. Note that you need not convert the quantized values to sequences of binary digits.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">quantize</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">bit_depth</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an array of N samples and a bit-depth of M, return the array of</span>
<span class="sd">    quantized samples derived from the domain [samples.min(), samples.max()]</span>
<span class="sd">    that has been quantized into 2**M evenly-spaced values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : numpy.ndarray, shape-(N,)</span>
<span class="sd">        An array of N samples</span>

<span class="sd">    bit_depth: int</span>
<span class="sd">        The bit-depth, M, used to quantize the samples among</span>
<span class="sd">        2**M evenly spaced values spanning [samples.min(), samples.max()]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    quantized_samples : numpy.ndarray, shape-(N,)</span>
<span class="sd">        The corresponding array where each sample has been replaced</span>
<span class="sd">        by the nearest quantized value</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; samples = np.array([0, .25, .75, 1])</span>
<span class="sd">    &gt;&gt;&gt; quantize(samples, 1) # bit-depth 1: quantize among 2**1 values</span>
<span class="sd">    array([0., 0., 1., 1.])</span>
<span class="sd">    &gt;&gt;&gt; quantize(samples, 2) # bit-depth 2: quantize among 2**2 values</span>
<span class="sd">    array([0., 0.3333, .6666, 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># include this line of code to prevent yourself from</span>
    <span class="c1"># trying such a large bit-depth that your computer</span>
    <span class="c1"># becomes overburdened</span>
    <span class="k">assert</span> <span class="n">bit_depth</span> <span class="o">&lt;=</span> <span class="mi">14</span><span class="p">,</span> <span class="s2">&quot;Exceeding this bit-depth might tank your computer!&quot;</span>

    <span class="c1"># your code here</span>
</pre></div>
</div>
</div>
<p>Having quantized the measurements of our voltmeter, it is trivial to map each quantized value with its corresponding sequence of <span class="math notranslate nohighlight">\(N_b\)</span> bits. When we store this data in a digital file on our computer, we can include the requisite information (in the “header” of the file) needed to correspond each distinct bit sequence back to its associated measurement value. Recall that we would also need to record the temporal sampling rate that we used as well, so that we reconstruct the temporal layout
of our samples.</p>
<p>An audio signal encoded using a shallow bit-depth will play back with severe artifacts: smoothly varying fluctuations in air pressure of the original sound wave will be reconstructed with sharp transitions between flattened, quantized amplitudes. Our ears are quite sensitive to these artificial aberrations; we will have the chance to “resample” some of our favorite songs with different bit-depths and sample rates to see how these factors affect the our perception of the music.</p>
<p>The standard bit-depth for audio encoding is <span class="math notranslate nohighlight">\(16\)</span> bits (or <span class="math notranslate nohighlight">\(2\)</span> bytes); this affords us a high “resolution” of <span class="math notranslate nohighlight">\(2^{16 }= 65,536\)</span> distinct quanta for recording values from our voltmeter.</p>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>Reading Comprehension: The Size of an Audio File</strong></p>
<p>Find an mp3 file on your computer or device, and check to see how long the song is. Based on this number, and using the standard PCM encoding parameters:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(f_s = 44,100\; \mathrm{Hz}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(N_d = 16\; \mathrm{bits}\)</span></p></li>
</ul>
<p>compute how large you would expect this digital audio file to be, had it been written using PCM encoding, to the nearest tenth of a megabyte. Compare this to the actual size of the file on your computer. You should see that the size of mp3 file is considerably smaller than your calculated PCM file. This is because the mp3 format is a compressed audio format that can reduce the memory footprint of a recording by, among other things, filtering out data that would be imperceivable to the listener.</p>
<p>In the next section of this module, we will learn about the Fourier transform, which is a key mathematical method by which we can “excise” inaudible parts of the data being encoded into the mp3 file.</p>
</div>
<div class="admonition note">
<p class="admonition-title fa fa-exclamation-circle"><strong>Reading Comprehension: Putting It All Together</strong></p>
<p>Study the PCM sampling process depicted below. What is the temporal sampling rate and apparent bit-depth used here?</p>
</div>
<div style="text-align: center">
<p>
<img src="../_images/fs_2_Nb_3.png" alt="Figure for putting it all together reading comprehension question" width="600">
</p>
</div></div>
</div>
<div class="section" id="Reading-Comprehension-Exercise-Solutions">
<h2>Reading Comprehension Exercise Solutions<a class="headerlink" href="#Reading-Comprehension-Exercise-Solutions" title="Permalink to this headline">¶</a></h2>
<p><strong>Sample Rate: Solution</strong></p>
<p>Given an analog signal that lasts for <span class="math notranslate nohighlight">\(127.2 \mathrm{seconds}\)</span>, if we use sample at a rate of <span class="math notranslate nohighlight">\(0.5 \; \mathrm{Hz}\)</span>, how many samples should we expect to collect? Compute your answer using pen and paper and using Python.</p>
<div class="math notranslate nohighlight">
\begin{equation}
N_{\mathrm{samples}} = \lfloor f_s T \rfloor + 1 = \bigg\lfloor 0.5\;\frac{1}{\mathrm{seconds}}\times 127.2\;\mathrm{seconds} \bigg\rfloor + 1 = \lfloor 63.6 \rfloor + 1 = 64
\end{equation}</div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fs</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># Hz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="mf">127.2</span> <span class="c1"># seconds</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># number of samples</span>
<span class="go">64</span>
</pre></div>
</div>
<p><strong>Writing a Sampler: Solution</strong></p>
<p>The function <code class="docutils literal notranslate"><span class="pre">numpy.arange(N)</span></code> produces the array <span class="math notranslate nohighlight">\([0,\;1,\dots\;N-1\big]\)</span>, which can be conveniently transformed into the array of times at which we we sample our signal: <span class="math notranslate nohighlight">\(\big[0,\;\Delta t,\;\ldots ,\;(N - 1)\Delta t\big]\)</span>. Once we have done this, we can simply leverage the assumption that <code class="docutils literal notranslate"><span class="pre">signal</span></code> is a <a class="reference external" href="https://www.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/VectorizedOperations.html">vectorized function</a> and call it on this array of times.</p>
<p>Note that, in my solution, I have added an asterisk in my function signature, preceding <code class="docutils literal notranslate"><span class="pre">duration</span></code>. This ensures that <code class="docutils literal notranslate"><span class="pre">duration</span></code> and <code class="docutils literal notranslate"><span class="pre">sampling_rate</span></code> must have their values be specified <em>by name</em> when invoking <code class="docutils literal notranslate"><span class="pre">temporal_sampler</span></code>. This ensures that we do not accidentally pass our duration as our sampling rate and vice versa.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">floor</span>


<span class="k">def</span> <span class="nf">temporal_sampler</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts samples from an analog signal according to the specified sampling rate,</span>
<span class="sd">    returning the times and the corresponding samples</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : Callable[[ndarray], ndarray]</span>
<span class="sd">        Another Python function (i.e. a &quot;callable&quot;), which behaves like f(t)</span>
<span class="sd">        and accepts a time value (in seconds) as an input and returns a</span>
<span class="sd">        measurement (in volts) as an output. You can expect this to behave like</span>
<span class="sd">        a vectorized function i.e. it can be passed a NumPy-array of input times</span>
<span class="sd">        and it will return a corresponding array of measurements.</span>

<span class="sd">    duration : float</span>
<span class="sd">        The duration of the signal, specified in seconds (a non-negative float)</span>

<span class="sd">    sampling_rate : float</span>
<span class="sd">        The sampling rate specified in Hertz.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (times, samples) : Tuple[ndarray, ndarray]</span>
<span class="sd">        The shape-(N,) array of times and the corresponding shape-(N,) array</span>
<span class="sd">        samples extracted from the analog signal</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N_samples</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">sampling_rate</span> <span class="o">*</span> <span class="n">duration</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># shape-(N,) array of times at which we sample the analog signal</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_samples</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">)</span>  <span class="c1"># seconds</span>

    <span class="c1"># shape-(N,) array of samples extracted from the analog signal</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">signal</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">samples</span>
</pre></div>
</div>
</div>
<p><strong>Aliasing: Solution</strong></p>
<p>Using the analog signal</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># Hz</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot this <span class="math notranslate nohighlight">\(10 \; \mathrm{Hz}\)</span> sinusoidal signal densely (so that it looks continuous) over a <span class="math notranslate nohighlight">\(0.5 \;\mathrm{second}\)</span> interval. Now, use your <code class="docutils literal notranslate"><span class="pre">temporal_sampler</span></code> function from the previous exercise to sample this signal, <strong>using a sampling rate that matches the frequency of the signal</strong> (<span class="math notranslate nohighlight">\(10 \; \mathrm{Hz}\)</span>); plot these samples on top of the analog signal. What do you notice about these samples?</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">floor</span>

<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="k">def</span> <span class="nf">plot_samples_on_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">):</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

    <span class="c1"># we densely sample the analog signal to make it look like</span>
    <span class="c1"># it is continuous</span>
    <span class="n">dense_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>  <span class="c1"># seconds</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dense_t</span><span class="p">,</span> <span class="n">signal</span><span class="p">(</span><span class="n">dense_t</span><span class="p">),</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Analog Signal&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="n">times</span><span class="p">,</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">temporal_sampler</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">)</span>

    <span class="c1"># creates the stem plot indicating our samples</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span>
        <span class="n">times</span><span class="p">,</span>
        <span class="n">samples</span><span class="p">,</span>
        <span class="s2">&quot;red&quot;</span><span class="p">,</span>
        <span class="n">markerfmt</span><span class="o">=</span><span class="s2">&quot;ro&quot;</span><span class="p">,</span>
        <span class="n">basefmt</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="p">,</span>
        <span class="n">use_line_collection</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time [seconds]&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Volts&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Discretizing an Analog Signal in Time&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># Hz</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_samples_on_signal</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/Audio_digitizing_signals_26_0.png" src="../_images/Audio_digitizing_signals_26_0.png" />
</div>
</div>
<p>What do you notice about these samples? Can you imagine a far simpler function that would produce the exact same samples?</p>
<blockquote>
<div><p>The samples all fall exactly on the same position of the signal’s periodic form. None of the signal’s dynamics are captured by these samples – we could have sampled a <em>constant</em> (flat) signal to the exact same effect, meaning that this sampled signal makes no noise. That is to say, this sampling rate causes our sinusoidal analog signal and a flat signal to be “aliases” of one another.</p>
</div></blockquote>
<p>Now, re-sample the signal at with the sampling rate doubled and plot the results. Do these samples do a better job of representing our signal?</p>
<p>Reflecting on this, and given that we humans can perceive tones with frequencies up to roughly <span class="math notranslate nohighlight">\(20,000\;\mathrm{Hz}\)</span>, why might the audio industry use a sampling rate of <span class="math notranslate nohighlight">\(44,100\;\mathrm{Hz}\)</span> for digitizing audio signals?</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_samples_on_signal</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mf">20.</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/Audio_digitizing_signals_29_0.png" src="../_images/Audio_digitizing_signals_29_0.png" />
<p>Doubling the sampling rate allows our samples to capture the frequency and periodicity of the analog signal. It breaks the “aliasing” that we were experiencing at the <span class="math notranslate nohighlight">\(10\;\mathrm{Hz}\)</span> sampling rate, where the samples appeared to reflect a constant signal. Similarly, we want our digital recording to capture the highest-frequency tones that we can perceive. We want to avoid matching the sampling rate of the highest frequency, lest it get “washed out” as a constant signal.</p>
</div>
</div>
<blockquote>
<div><p>The sampling rate of <span class="math notranslate nohighlight">\(44,100\;\mathrm{Hz}\)</span> exceeds the Nyquist rate for a <span class="math notranslate nohighlight">\(20,000\;\mathrm{Hz}\)</span> tone; this satisfies the Nyquist–Shannon sampling theorem, which provides some context for why this is the defacto sampling rate for the audio industry.</p>
</div></blockquote>
<p><strong>Quantization: Solution</strong></p>
<p>Write a python function called <code class="docutils literal notranslate"><span class="pre">quantize</span></code>, which performs the quantization process discussed above. Read the docstring for the function “stub” provided below. Note that you need not convert the quantized values to sequences of binary digits.</p>
<blockquote>
<div><p>Although we can complete this task using for-loops, it is more concise and efficient to leverage numpy’s semantics for <a class="reference external" href="https://www.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/VectorizedOperations.html">vectorized operations</a>. We will need to leverage <a class="reference external" href="https://www.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/Broadcasting.html">broadcasting</a> and <a class="reference external" href="https://www.pythonlikeyoumeanit.com/Module3_IntroducingNumpy/AdvancedIndexing.html#Integer-Array-Indexing">advanced indexing with integer
arrays</a> in our solution.</p>
</div></blockquote>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">quantize</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">bit_depth</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an array of N samples and a bit-depth of M, return the array of</span>
<span class="sd">    quantized samples derived from the domain [samples.min(), samples.max()]</span>
<span class="sd">    that has been quantized into 2**M evenly-spaced values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    samples : numpy.ndarray, shape-(N,)</span>
<span class="sd">        An array of N samples</span>

<span class="sd">    bit_depth: int</span>
<span class="sd">        The bit-depth, M, used to quantize the samples among</span>
<span class="sd">        2**M evenly spaced values spanning [samples.min(), samples.max()].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    quantized_samples : numpy.ndarray, shape-(N,)</span>
<span class="sd">        The corresponding array where each sample has been replaced</span>
<span class="sd">        by the nearest quantized value</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; samples = np.array([0, .25, .75, 1])</span>
<span class="sd">    &gt;&gt;&gt; quantize(samples, 1) # quantize among 2 values</span>
<span class="sd">    array([0., 0., 1., 1.])</span>
<span class="sd">    &gt;&gt;&gt; quantize(samples, 1) # quantize among 4 values</span>
<span class="sd">    array([0., 0.3333, .6666, 1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">bit_depth</span> <span class="o">&lt;=</span> <span class="mi">14</span><span class="p">,</span> <span class="s2">&quot;Exceeding this bit-depth might tank your computer!&quot;</span>

    <span class="c1"># create the 2**M evenly-spaced quantized values,</span>
    <span class="c1"># spanning [samples.min(), samples.max()]</span>
    <span class="n">quantized_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">samples</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">bit_depth</span><span class="p">)</span>

    <span class="c1"># Broadcast subtract: shape-(N, 1) w/ shape-(M**2,) -&gt; shape(N, M**2)</span>
    <span class="c1"># `abs_differences[i]` is the absolute difference between sample-i and</span>
    <span class="c1"># each of the M**2 quantized values</span>
    <span class="n">abs_differences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">quantized_values</span><span class="p">)</span>

    <span class="c1"># For each sample, find which quantized value it is closest to.</span>
    <span class="c1"># Produced shape-(N,) array on indices on [0, 2**M)</span>
    <span class="n">bin_lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">abs_differences</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Populate a shape-(N,) array, where each sample has been</span>
    <span class="c1"># replaced by its nearest quantized value. This leverages</span>
    <span class="c1"># advanced integer-array indexing</span>
    <span class="k">return</span> <span class="n">quantized_values</span><span class="p">[</span><span class="n">bin_lookup</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p><strong>The Size of an Audio File: Solution</strong></p>
<p>Using a four minute song as a reference, we would expect a PCM-encoded digital audio file, using a bit-depth of <span class="math notranslate nohighlight">\(16\)</span> bits and a sampling rate of <span class="math notranslate nohighlight">\(44.1\;\mathrm{kHz}\)</span> to take up:</p>
<div class="math notranslate nohighlight">
\begin{equation}
4 \;\mathrm{minutes}\times 60\;\frac{\mathrm{seconds}}{\mathrm{minute}}\times 44,100\;\frac{\mathrm{samples}}{\mathrm{second}}
 \times 16\;\frac{\mathrm{bits}}{\mathrm{sample}} \times \;\frac{1\; \mathrm{megabytes}}{2\times10^6\;\mathrm{bits}} = 21.2\; \mathrm{megabytes}
 \end{equation}</div><p>The song’s actual size as a high-quality (<span class="math notranslate nohighlight">\(320 \;\mathrm{kbps}\)</span>) mp3 file is <span class="math notranslate nohighlight">\(9.2 \;\mathrm{megabytes}\)</span>, which is about 43% the expected size of the PCM-encoded file.</p>
<p>It should be noted that the amount of compression achieved by the mp3 format depends on factors beyond a song’s size. The quality of the mp3 encoding being used and the actual sonic contents of the song both impact the compression factor.</p>
<p><strong>Putting It All Together: Solution</strong></p>
<p>The figure shows that four samples fit squarely within each <span class="math notranslate nohighlight">\(2 \;\mathrm{second}\)</span> interval on the plot, thus a temporal sampling rate of <span class="math notranslate nohighlight">\(2 \;\mathrm{Hz}\)</span> was used (<span class="math notranslate nohighlight">\(\frac{4 \;\mathrm{samples}} {2 \;\mathrm{seconds}} = 2 \;\mathrm{Hz}\)</span>). Furthermore, the voltmeter measurements are binned into <span class="math notranslate nohighlight">\(8\)</span> quantized values, thus a bit-depth of <span class="math notranslate nohighlight">\(N_b = \log_2{8} = 3\)</span> was used.</p>
</div>
<div class="section" id="Code-For-Reproducing-Figures">
<h2>Code For Reproducing Figures<a class="headerlink" href="#Code-For-Reproducing-Figures" title="Permalink to this headline">¶</a></h2>
<div class="section" id="Discretizing-an-Analog-Signal-in-Time">
<h3>Discretizing an Analog Signal in Time<a class="headerlink" href="#Discretizing-an-Analog-Signal-in-Time" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>


<span class="c1"># defining the &quot;analog signal&quot;</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>


<span class="k">def</span> <span class="nf">temporal_sampler</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extracts samples from an analog signal according to the</span>
<span class="sd">    specified sampling rate, returning the times and the</span>
<span class="sd">    corresponding samples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N_samples</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">sampling_rate</span> <span class="o">*</span> <span class="n">duration</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N_samples</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sampling_rate</span><span class="p">)</span>  <span class="c1"># seconds</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">signal</span><span class="p">(</span><span class="n">times</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">times</span><span class="p">,</span> <span class="n">samples</span>

<span class="k">def</span> <span class="nf">plot_samples_on_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">):</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

    <span class="c1"># we densely sample the analog signal to make it look like</span>
    <span class="c1"># it is continuous</span>
    <span class="n">dense_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>  <span class="c1"># seconds</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">dense_t</span><span class="p">,</span> <span class="n">signal</span><span class="p">(</span><span class="n">dense_t</span><span class="p">),</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Analog Signal&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="n">times</span><span class="p">,</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">temporal_sampler</span><span class="p">(</span><span class="n">signal</span><span class="o">=</span><span class="n">signal</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">duration</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">)</span>

    <span class="c1"># creates the stem plot indicating our samples</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">stem</span><span class="p">(</span>
        <span class="n">times</span><span class="p">,</span>
        <span class="n">samples</span><span class="p">,</span>
        <span class="s2">&quot;red&quot;</span><span class="p">,</span>
        <span class="n">markerfmt</span><span class="o">=</span><span class="s2">&quot;ro&quot;</span><span class="p">,</span>
        <span class="n">basefmt</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span>
        <span class="n">label</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="p">,</span>
        <span class="n">use_line_collection</span><span class="o">=</span><span class="bp">True</span>
    <span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time [seconds]&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Volts&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Discretizing an Analog Signal in Time&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span>


<span class="n">plot_samples_on_signal</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">10.7</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="Quantizing-Sine">
<h3>Quantizing Sine<a class="headerlink" href="#Quantizing-Sine" title="Permalink to this headline">¶</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">floor</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">notebook</span>

<span class="k">def</span> <span class="nf">quantize</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">bit_depth</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an array of N samples and a bit-depth of M, return the array of</span>
<span class="sd">    quantized samples derived from the domain [samples.min(), samples.max()]</span>
<span class="sd">    that has been quantized into 2**M evenly-spaced values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">bit_depth</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">,</span> <span class="s2">&quot;Exceeding this bit-depth might tank your computer!&quot;</span>
    <span class="n">quantized_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">samples</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">bit_depth</span><span class="p">)</span>
    <span class="n">abs_differences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">quantized_values</span><span class="p">)</span>
    <span class="n">bin_lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">abs_differences</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">quantized_values</span><span class="p">[</span><span class="n">bin_lookup</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">quantize2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;$N_b$ = {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">([])</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Exercises/WorkingWithMic.html" class="btn btn-neutral float-right" title="Exercises: Working with the Microphone" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="recording_sound.html" class="btn btn-neutral float-left" title="Microphones: Recording Sound as an Analog Signal" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ryan Soklaski

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>